# 部署与运维

<cite>
**本文档引用的文件**
- [Dockerfile](file://Dockerfile)
- [docker-compose.yml](file://docker-compose.yml)
- [docker-compose.dev.yml](file://docker-compose.dev.yml)
- [configs/config.yaml](file://configs/config.yaml)
- [test/config/test.yaml](file://test/config/test.yaml)
- [test/config/docker-compose.test.yml](file://test/config/docker-compose.test.yml)
- [internal/pkg/health/health.go](file://internal/pkg/health/health.go)
- [cmd/kratos-boilerplate/main.go](file://cmd/kratos-boilerplate/main.go)
- [Makefile](file://Makefile)
</cite>

## 目录
1. [概述](#概述)
2. [Docker镜像构建](#docker镜像构建)
3. [容器编排配置](#容器编排配置)
4. [外部化配置管理](#外部化配置管理)
5. [健康检查与监控](#健康检查与监控)
6. [部署策略](#部署策略)
7. [监控与日志](#监控与日志)
8. [故障排除](#故障排除)
9. [最佳实践](#最佳实践)

## 概述

本项目采用现代化的微服务架构，基于Go Kratos框架构建。部署方案涵盖从开发到生产环境的完整流程，包括Docker容器化、Kubernetes编排、监控告警和自动化部署策略。

## Docker镜像构建

### 多阶段构建优化

项目使用多阶段Docker构建来创建轻量级生产镜像：

```mermaid
flowchart TD
A["基础镜像<br/>openeuler:24.03-lts"] --> B["构建阶段<br/>安装Go、Node.js"]
B --> C["编译后端<br/>make build"]
B --> D["构建前端<br/>npm install & build"]
E["最终镜像<br/>openeuler:24.03-lts"] --> F["复制构建产物"]
F --> G["/app/bin/xredline"]
F --> H["/app/frontend/dist"]
G --> I["暴露端口<br/>8000, 9000"]
H --> I
```

**图表来源**
- [Dockerfile](file://Dockerfile#L1-L57)

### 构建过程详解

#### 第一阶段：构建环境准备
- 使用openEuler 24.03 LTS作为基础镜像
- 安装必要的构建工具：wget、tar、nodejs、npm、git、make
- 下载并安装Go 1.24.1版本
- 设置Go环境变量：GOPROXY、GO111MODULE、PATH

#### 第二阶段：应用构建
- 复制源代码到容器
- 后端构建：执行`make build`命令
- 前端构建：进入frontend目录，执行npm安装和构建

#### 第三阶段：生产镜像
- 从第一阶段复制构建产物
- 只保留必要的运行时依赖
- 设置工作目录和暴露端口

**章节来源**
- [Dockerfile](file://Dockerfile#L1-L57)

## 容器编排配置

### 开发环境编排

开发环境使用专门的docker-compose配置，提供热重载和调试功能：

```mermaid
graph TB
subgraph "开发环境"
Dev[开发容器<br/>Dockerfile.dev]
SSH[SSH服务<br/>端口2222]
Ports[端口映射<br/>8000, 9000, 9000]
Volumes[数据卷<br/>源码, 缓存]
end
subgraph "数据库服务"
DB[PostgreSQL<br/>端口5432]
Health[健康检查]
end
Dev --> DB
Dev --> SSH
Dev --> Ports
Dev --> Volumes
DB --> Health
```

**图表来源**
- [docker-compose.dev.yml](file://docker-compose.dev.yml#L1-L56)

### 生产环境编排

生产环境使用标准的docker-compose配置，专注于稳定性和性能：

```mermaid
sequenceDiagram
participant App as 应用容器
participant DB as 数据库容器
participant Redis as 缓存容器
participant Network as 网络层
App->>DB : 健康检查
DB-->>App : 检查成功
App->>Redis : 初始化连接
Redis-->>App : 连接建立
App->>Network : 注册服务
Network-->>App : 服务可用
Note over App,Network : 应用启动完成
```

**图表来源**
- [docker-compose.yml](file://docker-compose.yml#L1-L50)

### 服务依赖关系

容器之间存在明确的依赖关系：

1. **应用容器**依赖数据库容器的健康状态
2. **数据库容器**使用PostgreSQL 14镜像
3. **缓存容器**默认使用本地Redis实例
4. **网络隔离**：所有服务运行在独立的bridge网络中

**章节来源**
- [docker-compose.yml](file://docker-compose.yml#L1-L50)
- [docker-compose.dev.yml](file://docker-compose.dev.yml#L1-L56)

## 外部化配置管理

### 配置文件结构

项目采用YAML格式的外部化配置，支持多环境差异化设置：

```mermaid
classDiagram
class ConfigManager {
+loadConfig(path string) Config
+validateConfig(config Config) error
+mergeEnvironments(base, env Config) Config
}
class Bootstrap {
+Server ServerConfig
+Data DataConfig
+Auth AuthConfig
+Plugins PluginConfig
+Features FeatureConfig
}
class ServerConfig {
+HTTP HTTPConfig
+GRPC GRPCConfig
}
class DataConfig {
+Database DatabaseConfig
+Redis RedisConfig
}
ConfigManager --> Bootstrap
Bootstrap --> ServerConfig
Bootstrap --> DataConfig
```

**图表来源**
- [configs/config.yaml](file://configs/config.yaml#L1-L48)
- [cmd/kratos-boilerplate/main.go](file://cmd/kratos-boilerplate/main.go#L1-L92)

### 环境配置差异

#### 开发环境配置
- JWT密钥：`your-super-secret-jwt-key-here`
- 数据库连接：`postgresql://postgres:postgres@cross-redline-db:5432/test?sslmode=disable`
- 功能开关：启用插件和安全沙箱
- 日志级别：info

#### 测试环境配置
- 固定验证码：`123456`
- 数据库连接：`postgresql://postgres:postgres@localhost:5432/test_db?sslmode=disable`
- 自动清理：启用测试数据自动清理
- 超时设置：30秒单元测试超时

#### 生产环境配置
- 加密JWT密钥：使用环境变量或密钥管理服务
- 数据库连接：使用SSL加密连接
- 安全配置：启用沙箱和内存限制
- 监控集成：集成Prometheus和Jaeger

**章节来源**
- [configs/config.yaml](file://configs/config.yaml#L1-L48)
- [test/config/test.yaml](file://test/config/test.yaml#L1-L41)

## 健康检查与监控

### 健康检查端点设计

系统实现了完整的健康检查机制，支持多种检查类型：

```mermaid
classDiagram
class HealthChecker {
+checkers []Checker
+timeout time.Duration
+logger Logger
+AddChecker(checker Checker)
+Check(ctx Context) OverallHealth
}
class Checker {
<<interface>>
+Check(ctx Context) CheckResult
+Name() string
}
class DatabaseChecker {
+name string
+ping func(ctx Context) error
+Check(ctx Context) CheckResult
}
class CacheChecker {
+name string
+ping func(ctx Context) error
+Check(ctx Context) CheckResult
}
class HTTPChecker {
+name string
+url string
+client HttpClient
+Check(ctx Context) CheckResult
}
class MemoryChecker {
+name string
+threshold float64
+Check(ctx Context) CheckResult
}
HealthChecker --> Checker
Checker <|-- DatabaseChecker
Checker <|-- CacheChecker
Checker <|-- HTTPChecker
Checker <|-- MemoryChecker
```

**图表来源**
- [internal/pkg/health/health.go](file://internal/pkg/health/health.go#L1-L551)

### 健康检查类型

#### 1. 存活检查（Liveness）
- 检查服务基本功能是否正常
- 返回状态码：200（健康）、503（不健康）
- 用途：容器重启决策

#### 2. 就绪检查（Readiness）
- 检查服务是否准备好处理请求
- 依赖必需的服务检查项
- 用途：负载均衡器路由决策

#### 3. 自定义检查器
- 数据库连接检查
- 缓存连接检查
- HTTP服务可用性检查
- 内存使用率检查

### Kubernetes集成

健康检查端点`/healthz`可以被Kubernetes用于：

1. **存活探针**：检测容器是否需要重启
2. **就绪探针**：决定容器是否接收流量
3. **启动探针**：等待应用完全启动

**章节来源**
- [internal/pkg/health/health.go](file://internal/pkg/health/health.go#L1-L551)

## 部署策略

### 蓝绿部署

```mermaid
sequenceDiagram
participant LB as 负载均衡器
participant Green as 绿色环境
participant Blue as 蓝色环境
participant DB as 数据库
Note over Green,Blue : 初始状态：蓝色环境运行
LB->>Blue : 流量转发
Blue->>DB : 数据读写
Note over Green,Blue : 部署新版本到绿色环境
Green->>Green : 部署应用
Green->>DB : 数据读写
Note over Green,Blue : 健康检查通过
LB->>Green : 流量切换
Green->>DB : 数据读写
Note over Green,Blue : 蓝色环境退役
LB->>Green : 继续流量转发
```

### 滚动更新

```mermaid
flowchart TD
A["开始滚动更新"] --> B["停止第一个Pod"]
B --> C["运行新版本Pod"]
C --> D{"健康检查"}
D --> |失败| E["回滚到上一个版本"]
D --> |成功| F["继续下一个Pod"]
F --> G{"所有Pod更新完成?"}
G --> |否| B
G --> |是| H["更新完成"]
E --> I["通知管理员"]
H --> J["监控系统状态"]
```

### 回滚策略

1. **自动回滚**：健康检查失败时自动回滚
2. **手动回滚**：通过版本标签选择历史版本
3. **金丝雀发布**：逐步扩大新版本流量比例

## 监控与日志

### Prometheus指标暴露

系统集成了Prometheus监控，暴露以下关键指标：

- **HTTP请求指标**：请求数、响应时间、错误率
- **数据库指标**：连接数、查询延迟、慢查询
- **缓存指标**：命中率、过期键数、内存使用
- **应用指标**：内存使用、CPU使用率、goroutine数量

### 日志收集架构

```mermaid
graph LR
subgraph "应用层"
App[应用程序]
Logs[结构化日志]
end
subgraph "日志收集"
Filebeat[Filebeat]
Logstash[Logstash]
end
subgraph "存储层"
ES[Elasticsearch]
Kibana[Kibana]
end
App --> Logs
Logs --> Filebeat
Filebeat --> Logstash
Logstash --> ES
ES --> Kibana
```

### 告警配置

基于监控指标设置告警规则：

1. **高错误率告警**：HTTP 5xx错误率超过5%
2. **响应时间告警**：平均响应时间超过2秒
3. **资源使用告警**：内存使用率超过80%
4. **服务可用性告警**：健康检查连续失败

## 故障排除

### 常见问题诊断

#### 1. 容器启动失败
- 检查Dockerfile构建日志
- 验证环境变量配置
- 确认端口冲突

#### 2. 数据库连接问题
- 验证数据库容器健康状态
- 检查网络连通性
- 确认连接字符串格式

#### 3. 健康检查失败
- 查看健康检查端点响应
- 检查依赖服务状态
- 分析日志输出

### 调试工具

项目提供了多种调试工具：

- **日志检查器**：验证日志使用合规性
- **测试套件**：完整的单元和集成测试
- **端到端测试**：模拟真实用户场景

**章节来源**
- [Makefile](file://Makefile#L1-L151)

## 最佳实践

### 安全配置

1. **密钥管理**：使用环境变量或密钥管理服务
2. **网络隔离**：容器间网络隔离和访问控制
3. **镜像扫描**：定期扫描容器镜像安全漏洞
4. **权限最小化**：容器运行时使用非root用户

### 性能优化

1. **资源限制**：为容器设置合理的CPU和内存限制
2. **连接池**：优化数据库和缓存连接池配置
3. **缓存策略**：合理设置缓存过期时间和命中率
4. **并发控制**：限制并发请求数和goroutine数量

### 运维自动化

1. **CI/CD流水线**：自动化构建、测试和部署
2. **基础设施即代码**：使用Terraform管理基础设施
3. **配置管理**：集中化配置管理和版本控制
4. **监控告警**：完善的监控体系和告警机制

### 文档维护

1. **部署文档**：详细的部署步骤和配置说明
2. **操作手册**：常见运维操作和故障处理
3. **变更记录**：版本升级和配置变更记录
4. **知识库**：技术问题和解决方案积累