# 字段级加密方案

<cite>
**本文档引用的文件**
- [manager.go](file://internal/pkg/kms/manager.go)
- [datakey.go](file://internal/pkg/kms/datakey.go)
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go)
- [interfaces.go](file://internal/pkg/kms/interfaces.go)
- [kms.go](file://internal/biz/kms.go)
- [kms.go](file://internal/data/kms.go)
- [aes.go](file://internal/pkg/crypto/aes.go)
- [auth.go](file://internal/data/auth.go)
- [000002_create_kms_data_keys.up.sql](file://migrations/000002_create_kms_data_keys.up.sql)
- [crypto_service_test.go](file://internal/pkg/kms/crypto_service_test.go)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构概览](#项目结构概览)
3. [核心组件分析](#核心组件分析)
4. [架构设计](#架构设计)
5. [详细组件分析](#详细组件分析)
6. [密钥管理体系](#密钥管理体系)
7. [加密解密流程](#加密解密流程)
8. [数据库迁移与存储](#数据库迁移与存储)
9. [性能考虑](#性能考虑)
10. [故障处理与安全审计](#故障处理与安全审计)
11. [总结](#总结)

## 简介

本文档全面描述了基于KMS（密钥管理服务）的字段级加密架构设计。该方案采用分层密钥体系，通过数据密钥（Data Key）与根密钥（Root Key）的分离设计，实现了高安全性、高性能的敏感数据保护机制。

该架构的核心特点包括：
- **分层密钥体系**：根密钥负责保护数据密钥，数据密钥负责加密具体业务数据
- **AES-GCM算法**：采用业界标准的对称加密算法，提供认证加密功能
- **密钥缓存机制**：优化性能，减少重复密钥查询开销
- **自动密钥轮换**：定期更新数据密钥，增强安全性
- **完整的生命周期管理**：从密钥生成到销毁的全生命周期管理

## 项目结构概览

```mermaid
graph TB
subgraph "应用层"
A[业务逻辑层]
B[数据访问层]
end
subgraph "KMS核心包"
C[KMS Manager]
D[DataKey Manager]
E[Crypto Service]
F[Root Key Generator]
end
subgraph "存储层"
G[数据库存储]
H[密钥缓存]
end
subgraph "加密组件"
I[AES-GCM实现]
J[IV管理]
K[加解密封装]
end
A --> C
B --> C
C --> D
C --> E
C --> F
D --> G
E --> H
E --> I
I --> J
I --> K
```

**图表来源**
- [manager.go](file://internal/pkg/kms/manager.go#L1-L50)
- [datakey.go](file://internal/pkg/kms/datakey.go#L1-L30)
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go#L1-L30)

## 核心组件分析

### KMS Manager（KMS管理器）

KMS Manager是整个加密系统的核心协调器，负责初始化、管理和协调各个子组件的工作。

```mermaid
classDiagram
class KMSManager {
+Initialize(ctx, config) error
+GetActiveDataKey(ctx) DataKey
+RotateDataKey(ctx) DataKey
+EncryptField(ctx, field, value) EncryptedField
+DecryptField(ctx, field) []byte
+GetStatus(ctx) KMSStatus
+PerformMaintenance(ctx) error
+Close() error
}
class kmsManager {
-config KMSConfig
-rootKeyGen RootKeyGenerator
-dataKeyManager DataKeyManager
-cryptoService CryptoService
-storage KeyStorage
-rotationTicker Ticker
-initialized bool
-shutdown bool
+ensureActiveDataKey(ctx) error
+startAutoRotation()
+checkInitialized() error
}
KMSManager <|-- kmsManager : 实现
```

**图表来源**
- [manager.go](file://internal/pkg/kms/manager.go#L15-L30)
- [interfaces.go](file://internal/pkg/kms/interfaces.go#L1-L50)

### DataKey Manager（数据密钥管理器）

DataKey Manager专门负责数据密钥的生成、存储和管理，确保每个业务数据都有独立的加密密钥。

```mermaid
classDiagram
class DataKeyManager {
+GenerateDataKey(ctx, algorithm) DataKey
+GetActiveDataKey(ctx) DataKey
+GetDataKeyByVersion(ctx, version) DataKey
+RotateDataKey(ctx) DataKey
+EncryptWithDataKey(ctx, plaintext, version) EncryptedField
+DecryptWithDataKey(ctx, field) []byte
}
class dataKeyManager {
-rootKey []byte
-storage KeyStorage
-config KMSConfig
+encryptWithRootKey(plaintext) []byte
+decryptDataKey(dataKey) error
+generateVersion() string
}
DataKeyManager <|-- dataKeyManager : 实现
```

**图表来源**
- [datakey.go](file://internal/pkg/kms/datakey.go#L15-L30)
- [interfaces.go](file://internal/pkg/kms/interfaces.go#L95-L125)

### Crypto Service（加密服务）

Crypto Service提供统一的加解密接口，内部集成了密钥缓存机制，优化性能表现。

```mermaid
classDiagram
class CryptoService {
+EncryptField(ctx, field, value) EncryptedField
+DecryptField(ctx, field) []byte
+HashField(value) string
+EncryptBatch(ctx, fields) map[string]EncryptedField
+DecryptBatch(ctx, fields) map[string][]byte
+ClearCache()
}
class cryptoService {
-dataKeyManager DataKeyManager
-cache keyCache
-log Helper
+getActiveDataKey(ctx) DataKey
+getDataKeyByVersion(ctx, version) DataKey
+encryptWithDataKey(key, plaintext) []byte
+decryptWithDataKey(key, ciphertext) []byte
+isKeyExpired(key) bool
}
class keyCache {
-activeKey DataKey
-versionMap map[string]DataKey
-mu sync.RWMutex
}
CryptoService <|-- cryptoService : 实现
cryptoService --> keyCache : 使用
```

**图表来源**
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go#L15-L40)
- [interfaces.go](file://internal/pkg/kms/interfaces.go#L125-L150)

**章节来源**
- [manager.go](file://internal/pkg/kms/manager.go#L1-L308)
- [datakey.go](file://internal/pkg/kms/datakey.go#L1-L251)
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go#L1-L321)

## 架构设计

### 分层密钥体系

该架构采用两层密钥体系设计，实现了密钥的安全隔离和灵活管理：

```mermaid
graph TD
subgraph "根密钥层"
RK[Root Key<br/>根密钥]
end
subgraph "数据密钥层"
DK1[Data Key v1<br/>数据密钥版本1]
DK2[Data Key v2<br/>数据密钥版本2]
DK3[Data Key vn<br/>数据密钥版本n]
end
subgraph "业务数据层"
BD1[用户邮箱]
BD2[用户电话]
BD3[用户姓名]
BD4[支付信息]
end
RK --> DK1
RK --> DK2
RK --> DK3
DK1 --> BD1
DK1 --> BD2
DK2 --> BD3
DK3 --> BD4
style RK fill:#ff9999
style DK1 fill:#99ccff
style DK2 fill:#99ccff
style DK3 fill:#99ccff
style BD1 fill:#99ff99
style BD2 fill:#99ff99
style BD3 fill:#99ff99
style BD4 fill:#99ff99
```

**图表来源**
- [datakey.go](file://internal/pkg/kms/datakey.go#L30-L80)
- [kms.go](file://internal/biz/kms.go#L10-L20)

### 系统架构总览

```mermaid
sequenceDiagram
participant App as 应用程序
participant KM as KMS Manager
participant DKM as DataKey Manager
participant CS as Crypto Service
participant Storage as 数据库存储
App->>KM : 请求加密字段
KM->>CS : EncryptField()
CS->>DKM : GetActiveDataKey()
DKM->>Storage : 查询活跃密钥
Storage-->>DKM : 返回密钥
DKM-->>CS : 返回明文密钥
CS->>CS : AES-GCM加密
CS-->>KM : 返回加密字段
KM-->>App : 返回加密结果
Note over App,Storage : 解密流程类似，但方向相反
```

**图表来源**
- [manager.go](file://internal/pkg/kms/manager.go#L120-L140)
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go#L42-L70)

**章节来源**
- [manager.go](file://internal/pkg/kms/manager.go#L1-L308)
- [datakey.go](file://internal/pkg/kms/datakey.go#L1-L251)
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go#L1-L321)

## 详细组件分析

### 密钥生成与加密流程

#### 数据密钥生成过程

```mermaid
flowchart TD
Start([开始生成数据密钥]) --> GenRandom[生成32字节随机密钥]
GenRandom --> EncryptRoot[使用根密钥加密]
EncryptRoot --> CreateObj[创建DataKey对象]
CreateObj --> SaveDB[保存到数据库]
SaveDB --> Return([返回数据密钥])
style Start fill:#e1f5fe
style Return fill:#e8f5e8
style EncryptRoot fill:#fff3e0
style SaveDB fill:#fce4ec
```

**图表来源**
- [datakey.go](file://internal/pkg/kms/datakey.go#L30-L60)

#### AES-GCM算法实现

系统采用AES-GCM（Galois/Counter Mode）作为主要加密算法，具有以下优势：

1. **认证加密**：同时提供机密性和完整性保护
2. **高效性能**：硬件加速支持，适合大规模数据处理
3. **标准化**：广泛接受的国际标准

```go
// AES-GCM加密实现示例
block, err := aes.NewCipher(dataKey.Key)
gcm, err := cipher.NewGCM(block)
nonce := make([]byte, gcm.NonceSize())
rand.Read(nonce)
ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
```

### 密钥缓存机制

为了提高性能，Crypto Service实现了两级缓存机制：

```mermaid
graph LR
subgraph "缓存层次"
A[活跃密钥缓存<br/>activeKey]
B[版本密钥缓存<br/>versionMap]
end
subgraph "缓存策略"
C[读写锁保护]
D[双重检查锁定]
E[过期检查]
end
A --> C
B --> C
C --> D
D --> E
style A fill:#e8f5e8
style B fill:#e8f5e8
style C fill:#e1f5fe
style D fill:#e1f5fe
style E fill:#e1f5fe
```

**图表来源**
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go#L180-L220)

### 自动密钥轮换

系统支持定时密钥轮换，确保长期安全性：

```mermaid
sequenceDiagram
participant Timer as 定时器
participant KM as KMS Manager
participant DKM as DataKey Manager
participant Storage as 数据库
Timer->>KM : 触发轮换事件
KM->>DKM : RotateDataKey()
DKM->>DKM : 生成新密钥
DKM->>Storage : 保存新密钥
DKM->>Storage : 停用旧密钥
DKM-->>KM : 返回新密钥
KM->>KM : 清除缓存
KM-->>Timer : 轮换完成
Note over Timer,Storage : 新密钥立即生效，旧密钥逐步失效
```

**图表来源**
- [manager.go](file://internal/pkg/kms/manager.go#L250-L280)

**章节来源**
- [datakey.go](file://internal/pkg/kms/datakey.go#L30-L100)
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go#L180-L250)
- [manager.go](file://internal/pkg/kms/manager.go#L250-L308)

## 密钥管理体系

### 数据密钥结构设计

```mermaid
erDiagram
DATA_KEY {
string id PK
string version
string algorithm
byte[] key
byte[] encrypted_key
datetime created_at
datetime expires_at
boolean is_active
}
ENCRYPTED_FIELD {
byte[] value
string version
string algorithm
}
KMS_CONFIG {
string seed
string salt
int iterations
int key_length
duration rotate_interval
string algorithm
string storage_type
}
DATA_KEY ||--|| ENCRYPTED_FIELD : "使用"
KMS_CONFIG ||--|| DATA_KEY : "配置"
```

**图表来源**
- [kms.go](file://internal/biz/kms.go#L10-L80)

### 密钥生命周期管理

```mermaid
stateDiagram-v2
[*] --> 生成中
生成中 --> 活跃 : 密钥生成成功
活跃 --> 过期 : 到期时间到达
活跃 --> 停用 : 主动停用
过期 --> 清理 : 定期清理
停用 --> 清理 : 定期清理
清理 --> [*]
note right of 活跃
- 提供加密解密服务
- 支持密钥缓存
- 参与自动轮换
end note
note right of 过期
- 仍可解密历史数据
- 不再用于新加密
- 准备清理阶段
end note
```

### 密钥存储与检索

系统采用数据库存储密钥，支持高效的密钥检索：

```sql
-- 活跃密钥查询（优先级最高）
SELECT * FROM data_keys 
WHERE is_active = true 
  AND expires_at > NOW() 
ORDER BY created_at DESC 
LIMIT 1;

-- 版本密钥查询（支持历史解密）
SELECT * FROM data_keys 
WHERE version = ? 
  AND expires_at > NOW();
```

**章节来源**
- [kms.go](file://internal/biz/kms.go#L10-L80)
- [kms.go](file://internal/data/kms.go#L50-L150)

## 加密解密流程

### 完整调用链路

```mermaid
sequenceDiagram
participant Business as 业务层
participant Repo as 数据访问层
participant KMS as KMS Manager
participant Crypto as Crypto Service
participant DB as 数据库
Note over Business,DB : 存储敏感字段流程
Business->>Repo : CreateUser(user)
Repo->>Repo : 加密敏感字段
Note right of Repo : email, phone, name
Repo->>KMS : EncryptField(fieldName, value)
KMS->>Crypto : EncryptField(ctx, field, value)
Crypto->>Crypto : 获取活跃密钥
Crypto->>Crypto : AES-GCM加密
Crypto-->>KMS : 返回加密字段
KMS-->>Repo : 返回加密结果
Repo->>DB : INSERT with encrypted data
Note over Business,DB : 读取敏感字段流程
Business->>Repo : GetUser(username)
Repo->>DB : SELECT encrypted fields
DB-->>Repo : 返回加密数据
Repo->>KMS : DecryptField(encryptedField)
KMS->>Crypto : DecryptField(ctx, field)
Crypto->>Crypto : 获取对应版本密钥
Crypto->>Crypto : AES-GCM解密
Crypto-->>KMS : 返回明文数据
KMS-->>Repo : 返回明文结果
Repo-->>Business : 返回完整用户对象
```

**图表来源**
- [auth.go](file://internal/data/auth.go#L100-L150)
- [manager.go](file://internal/pkg/kms/manager.go#L120-L140)

### 批量加解密优化

系统支持批量加解密操作，显著提升性能：

```mermaid
flowchart TD
Start([批量操作开始]) --> GetActive[获取活跃密钥]
GetActive --> BatchLoop{遍历字段}
BatchLoop --> |有字段| Encrypt[使用同一密钥加密]
BatchLoop --> |无字段| Return[返回结果]
Encrypt --> Store[存储加密结果]
Store --> BatchLoop
Return --> End([批量操作结束])
style Start fill:#e1f5fe
style End fill:#e8f5e8
style GetActive fill:#fff3e0
style Encrypt fill:#e8f5e8
```

**图表来源**
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go#L80-L120)

### 错误处理与恢复

系统实现了完善的错误处理机制：

```go
// 加密错误处理示例
func (s *cryptoService) EncryptField(ctx context.Context, fieldName string, value []byte) (*biz.EncryptedField, error) {
    if len(value) == 0 {
        return nil, fmt.Errorf("value cannot be empty")
    }
    
    dataKey, err := s.getActiveDataKey(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to get active data key: %w", err)
    }
    
    encryptedValue, err := s.encryptWithDataKey(dataKey, value)
    if err != nil {
        return nil, fmt.Errorf("%w: %v", biz.ErrKeyEncryptionFail, err)
    }
    
    return &biz.EncryptedField{
        Value:     encryptedValue,
        Version:   dataKey.Version,
        Algorithm: dataKey.Algorithm,
    }, nil
}
```

**章节来源**
- [auth.go](file://internal/data/auth.go#L100-L200)
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go#L42-L120)

## 数据库迁移与存储

### 数据密钥表设计

```mermaid
erDiagram
kms_data_keys {
varchar id PK
integer version
varchar algorithm
bytea encrypted_key
varchar key_hash
varchar status
timestamp created_at
timestamp updated_at
timestamp expires_at
jsonb metadata
}
kms_key_stats {
varchar status
varchar algorithm
bigint key_count
timestamp earliest_created
timestamp latest_created
bigint expired_count
}
kms_data_keys ||--o{ kms_key_stats : "统计"
```

**图表来源**
- [000002_create_kms_data_keys.up.sql](file://migrations/000002_create_kms_data_keys.up.sql#L1-L30)

### 存储设计要点

1. **加密密钥存储**：只存储使用根密钥加密后的数据密钥
2. **版本控制**：支持多版本密钥共存，便于密钥轮换
3. **状态管理**：记录密钥状态（活跃、非活跃、过期、撤销）
4. **索引优化**：为常用查询条件建立索引
5. **统计视图**：提供密钥使用情况的统计信息

### 数据库操作接口

```go
// KMSRepo接口定义
type KMSRepo interface {
    SaveDataKey(ctx context.Context, key *DataKey) error
    GetActiveDataKey(ctx context.Context) (*DataKey, error)
    GetDataKeyByVersion(ctx context.Context, version string) (*DataKey, error)
    UpdateKeyStatus(ctx context.Context, version string, isActive bool) error
    CleanupExpiredKeys(ctx context.Context) error
    GetKeyStatistics(ctx context.Context) (*KeyStatistics, error)
}
```

**章节来源**
- [000002_create_kms_data_keys.up.sql](file://migrations/000002_create_kms_data_keys.up.sql#L1-L70)
- [kms.go](file://internal/data/kms.go#L10-L50)

## 性能考虑

### 密钥缓存策略

系统实现了智能缓存机制，显著提升性能：

```mermaid
graph TD
subgraph "缓存层级"
A[活跃密钥缓存<br/>activeKey]
B[版本密钥缓存<br/>versionMap]
end
subgraph "缓存优化"
C[读写锁保护]
D[双重检查锁定]
E[LRU淘汰策略]
F[内存池复用]
end
subgraph "性能指标"
G[缓存命中率 > 95%]
H[延迟 < 1ms]
I[吞吐量 > 10000 QPS]
end
A --> C
B --> C
C --> D
D --> E
E --> F
A --> G
B --> H
C --> I
```

### 批量处理优化

```go
// 批量加密示例
func (s *cryptoService) EncryptBatch(ctx context.Context, fields map[string][]byte) (map[string]*biz.EncryptedField, error) {
    // 一次性获取活跃密钥
    dataKey, err := s.getActiveDataKey(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to get active data key: %w", err)
    }
    
    // 使用同一密钥批量加密
    result := make(map[string]*biz.EncryptedField, len(fields))
    for fieldName, value := range fields {
        encryptedValue, err := s.encryptWithDataKey(dataKey, value)
        if err != nil {
            continue // 记录错误但继续处理其他字段
        }
        
        result[fieldName] = &biz.EncryptedField{
            Value:     encryptedValue,
            Version:   dataKey.Version,
            Algorithm: dataKey.Algorithm,
        }
    }
    
    return result, nil
}
```

### 内存管理

系统实现了安全的内存清理机制：

```go
// 密钥内存清理
func (s *cryptoService) clearDataKey(dataKey *biz.DataKey) {
    if len(dataKey.Key) > 0 {
        // 使用零值覆盖密钥数据
        for i := range dataKey.Key {
            dataKey.Key[i] = 0
        }
        dataKey.Key = nil
    }
}
```

## 故障处理与安全审计

### 故障降级策略

```mermaid
flowchart TD
Start([系统启动]) --> CheckInit{检查初始化}
CheckInit --> |未初始化| InitFail[初始化失败]
CheckInit --> |已初始化| HealthCheck{健康检查}
HealthCheck --> |健康| Normal[正常运行]
HealthCheck --> |异常| Fallback{降级策略}
Fallback --> |密钥不可用| ReadOnly[只读模式]
Fallback --> |存储异常| CacheOnly[缓存模式]
Fallback --> |网络异常| LocalMode[本地模式]
Normal --> Monitor[持续监控]
ReadOnly --> Monitor
CacheOnly --> Monitor
LocalMode --> Monitor
Monitor --> HealthCheck
style InitFail fill:#ffebee
style ReadOnly fill:#fff8e1
style CacheOnly fill:#f3e5f5
style LocalMode fill:#e8f5e8
```

### 安全审计功能

系统提供了完整的审计跟踪：

```go
// KMS状态信息
type KMSStatus struct {
    Initialized      bool              `json:"initialized"`
    Shutdown         bool              `json:"shutdown"`
    Algorithm        string            `json:"algorithm,omitempty"`
    RotateInterval   time.Duration     `json:"rotate_interval,omitempty"`
    ActiveKeyVersion string            `json:"active_key_version,omitempty"`
    ActiveKeyExpiry  time.Time         `json:"active_key_expiry,omitempty"`
    KeyStatistics    *biz.KeyStatistics  `json:"key_statistics,omitempty"`
}
```

### 日志记录与监控

```go
// 关键操作日志记录
func (m *kmsManager) logOperation(operation string, details map[string]interface{}) {
    m.log.With(
        "operation", operation,
        "timestamp", time.Now(),
        "details", details,
    ).Info("KMS operation performed")
}

// 性能监控指标
func (s *cryptoService) recordMetrics(operation string, duration time.Duration) {
    metrics.Record(
        "kms.operation_duration",
        float64(duration.Milliseconds()),
        "operation", operation,
    )
}
```

**章节来源**
- [crypto_service.go](file://internal/pkg/kms/crypto_service.go#L280-L321)
- [manager.go](file://internal/pkg/kms/manager.go#L280-L308)

## 总结

本文档详细描述了基于KMS的字段级加密架构设计，该方案具有以下核心优势：

### 技术优势

1. **安全性**：采用分层密钥体系，确保密钥安全隔离
2. **性能**：智能缓存机制，支持批量操作，提供高吞吐量
3. **可扩展性**：模块化设计，易于扩展和维护
4. **合规性**：符合行业标准，支持多种加密算法

### 架构特点

1. **分层设计**：清晰的职责分离，降低耦合度
2. **自动化运维**：自动密钥轮换和清理机制
3. **容错能力**：完善的错误处理和降级策略
4. **可观测性**：完整的监控和审计功能

### 应用场景

该架构适用于需要高安全性的企业级应用，特别是涉及个人隐私、金融数据等敏感信息的系统。通过合理的配置和部署，可以满足各种规模的应用需求。

### 最佳实践建议

1. **定期审查**：定期检查密钥使用情况和系统状态
2. **监控告警**：建立完善的监控和告警机制
3. **备份恢复**：制定密钥备份和灾难恢复计划
4. **权限控制**：严格控制密钥访问权限

通过本文档的详细分析，开发者可以深入理解该字段级加密方案的设计理念和实现细节，为实际项目开发提供有价值的参考。