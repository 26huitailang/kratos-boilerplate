# 测试策略

<cite>
**本文档引用的文件**
- [test/README.md](file://test/README.md)
- [test/scripts/run_all.sh](file://test/scripts/run_all.sh)
- [internal/biz/auth_test.go](file://internal/biz/auth_test.go)
- [test/bdd/auth/auth_bdd_test.go](file://test/bdd/auth/auth_bdd_test.go)
- [test/integration/database/auth_integration_test.go](file://test/integration/database/auth_integration_test.go)
- [test/e2e/scenarios/auth_e2e_test.go](file://test/e2e/scenarios/auth_e2e_test.go)
- [test/bdd/shared/test_suite.go](file://test/bdd/shared/test_suite.go)
- [internal/pkg/kms/mock_repository.go](file://internal/pkg/kms/mock_repository.go)
- [test/config/docker-compose.test.yml](file://test/config/docker-compose.test.yml)
- [test/config/test.yaml](file://test/config/test.yaml)
</cite>

## 目录
1. [概述](#概述)
2. [测试架构概览](#测试架构概览)
3. [单元测试策略](#单元测试策略)
4. [BDD行为驱动开发测试](#bdd行为驱动开发测试)
5. [集成测试策略](#集成测试策略)
6. [端到端测试策略](#端到端测试策略)
7. [测试基础设施](#测试基础设施)
8. [测试覆盖率与质量保障](#测试覆盖率与质量保障)
9. [CI/CD集成](#cicd集成)
10. [最佳实践指南](#最佳实践指南)

## 概述

Kratos Boilerplate项目采用多层次测试策略，构建了一个完整的测试金字塔体系。该测试框架涵盖了从单元测试到端到端测试的各个层面，确保代码质量和系统稳定性。

### 测试类型分类

项目实现了四种主要的测试类型：

- **单元测试 (Unit Tests)**: 验证单个函数或方法的逻辑
- **BDD测试 (Behavior Driven Development)**: 描述业务流程和用户行为
- **集成测试 (Integration Tests)**: 验证组件间的协作
- **端到端测试 (End-to-End Tests)**: 模拟完整的用户场景

```mermaid
graph TB
subgraph "测试金字塔"
E2E["端到端测试<br/>10% 覆盖率"]
Integration["集成测试<br/>20% 覆盖率"]
BDD["BDD测试<br/>30% 覆盖率"]
Unit["单元测试<br/>40% 覆盖率"]
end
subgraph "测试目标"
Business["业务规则验证"]
System["系统交互验证"]
Component["组件协作验证"]
Function["函数逻辑验证"]
end
E2E --> Business
Integration --> System
BDD --> Business
Unit --> Function
```

## 测试架构概览

### 目录结构

测试框架采用分层组织结构，清晰分离不同类型测试：

```
test/
├── README.md                    # 测试框架文档
├── bdd/                         # BDD测试套件
│   ├── auth/                    # 认证相关BDD测试
│   └── shared/                  # 共享的测试工具和助手
├── integration/                 # 集成测试
│   ├── database/                # 数据库集成测试
│   └── base_modules_test.go     # 基础模块集成测试
├── e2e/                         # 端到端测试
│   ├── scenarios/               # 测试场景
│   ├── fixtures/                # 测试数据
│   └── helpers/                 # 测试助手
├── config/                      # 测试配置
│   ├── test.yaml               # 测试环境配置
│   └── docker-compose.test.yml # 测试环境Docker配置
└── scripts/                     # 测试脚本
    ├── run_all.sh                # 运行所有测试
    ├── setup.sh                  # 测试环境设置
    └── teardown.sh               # 测试环境清理
```

### 测试工具链

项目使用现代化的测试工具组合：

- **单元测试**: Go标准测试包 + testify
- **BDD测试**: Ginkgo + Gomega
- **集成测试**: Go测试 + testify + testcontainers
- **端到端测试**: Ginkgo + Gomega + HTTP客户端

```mermaid
graph LR
subgraph "测试工具"
GoTesting["Go Testing<br/>标准测试包"]
Testify["Testify<br/>断言和模拟"]
Ginkgo["Ginkgo<br/>BDD框架"]
Gomega["Gomega<br/>匹配器"]
TestContainers["Test Containers<br/>容器化测试"]
end
subgraph "测试类型"
UnitTests["单元测试"]
BDDTests["BDD测试"]
IntegrationTests["集成测试"]
E2ETests["端到端测试"]
end
GoTesting --> UnitTests
Testify --> UnitTests
Ginkgo --> BDDTests
Gomega --> BDDTests
Ginkgo --> E2ETests
Gomega --> E2ETests
TestContainers --> IntegrationTests
```

## 单元测试策略

### 设计原则

单元测试专注于验证单个函数或方法的逻辑，具有以下特点：

- **快速执行**: 单个测试用例通常在毫秒级别完成
- **独立性**: 每个测试用例不应依赖其他测试的状态
- **可预测性**: 输入和输出应该完全可预测
- **隔离性**: 使用Mock隔离外部依赖

### Mock对象使用

项目广泛使用Mock对象来隔离外部依赖：

```go
// 模拟UserRepo
type mockUserRepo struct {
    mock.Mock
}

func (m *mockUserRepo) CreateUser(ctx context.Context, user *User) error {
    args := m.Called(ctx, user)
    return args.Error(0)
}

func (m *mockUserRepo) GetUser(ctx context.Context, username string) (*User, error) {
    args := m.Called(ctx, username)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}
```

### 测试用例示例

以下是认证服务的单元测试示例：

```go
func TestRegister_Success(t *testing.T) {
    // 准备测试依赖
    repo := new(mockUserRepo)
    captchaService := new(mockCaptchaService)
    logger := log.NewStdLogger(os.Stdout)

    // 配置模拟行为
    repo.On("GetUser", mock.Anything, "testuser").Return(nil, ErrUserNotFound)
    repo.On("GetUserByEmail", mock.Anything, "test@example.com").Return(nil, ErrUserNotFound)
    repo.On("CreateUser", mock.Anything, mock.AnythingOfType("*biz.User")).Return(nil)
    captchaService.On("Verify", mock.Anything, "captcha123", "123456").Return(true, nil)

    // 创建用例并执行
    config := DefaultAuthConfig
    uc := NewAuthUsecase(repo, captchaService, config, logger)

    err := uc.Register(context.Background(), "testuser", "Password123", "test@example.com", "13800138000", "captcha123", "123456")

    // 验证结果
    assert.NoError(t, err)
    repo.AssertExpectations(t)
    captchaService.AssertExpectations(t)
}
```

### 表驱动测试

项目采用表驱动测试模式提高测试覆盖率：

```go
func TestAdd_TableDriven(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"1+1", 1, 1, 2},
        {"2+2", 2, 2, 4},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := tt.a + tt.b
            assert.Equal(t, tt.want, got)
        })
    }
}
```

**章节来源**
- [internal/biz/auth_test.go](file://internal/biz/auth_test.go#L1-L529)

## BDD行为驱动开发测试

### BDD框架架构

BDD测试使用Ginkgo和Gomega框架，以自然语言描述用户行为和业务流程：

```mermaid
sequenceDiagram
participant Test as "BDD测试"
participant Suite as "测试套件"
participant Mock as "Mock对象"
participant Service as "业务服务"
Test->>Suite : BeforeEachSetup()
Suite->>Mock : 创建Mock仓储
Suite->>Service : 初始化业务服务
Test->>Mock : 设置期望值
Test->>Service : 执行业务操作
Service->>Mock : 调用依赖方法
Mock-->>Service : 返回模拟结果
Service-->>Test : 返回业务结果
Test->>Mock : AssertExpectations()
```

**图表来源**
- [test/bdd/shared/test_suite.go](file://test/bdd/shared/test_suite.go#L1-L231)
- [test/bdd/auth/auth_bdd_test.go](file://test/bdd/auth/auth_bdd_test.go#L1-L286)

### 测试场景描述

BDD测试使用自然语言描述测试场景：

```go
Describe("用户登录", func() {
    Context("当提供有效的用户名和密码时", func() {
        It("应该返回访问令牌", func() {
            // 准备测试数据
            loginReq := &v1.LoginRequest{
                Username:    "testuser",
                Password:    "password123",
                CaptchaId:   "captcha-123",
                CaptchaCode: "123456",
                TOTPCode:    "",
            }

            // 设置Mock期望
            mocks.UserRepo.On("GetUser", ctx, "testuser").Return(user, nil)
            mocks.UserRepo.On("GetLock", ctx, "testuser").Return(nil, biz.ErrUserNotFound)
            mocks.CaptchaService.On("Verify", ctx, "captcha-123", "123456").Return(true, nil)

            // 执行测试
            response, err := testSuite.Services.AuthService.Login(ctx, loginReq)

            // 验证结果
            Expect(err).NotTo(HaveOccurred())
            Expect(response).NotTo(BeNil())
            Expect(response.AccessToken).NotTo(BeEmpty())
        })
    })
})
```

### 测试套件管理

项目提供了统一的测试套件管理机制：

```go
type TestSuite struct {
    Logger   log.Logger
    Ctx      context.Context
    Data     *data.Data
    Cleanup  func()
    Services *Services
}

func (ts *TestSuite) SetupWithMocks() *MockRepositories {
    mocks := &MockRepositories{
        UserRepo:         NewMockUserRepo(),
        CaptchaService:   NewMockCaptchaService(),
        OperationLogRepo: NewMockOperationLogRepo(),
    }
    
    // 创建业务逻辑层和业务服务
    authUsecase := biz.NewAuthUsecase(mocks.UserRepo, mocks.CaptchaService, config, ts.Logger)
    authService := service.NewAuthService(authUsecase, ts.Logger)
    
    return mocks
}
```

**章节来源**
- [test/bdd/auth/auth_bdd_test.go](file://test/bdd/auth/auth_bdd_test.go#L1-L286)
- [test/bdd/shared/test_suite.go](file://test/bdd/shared/test_suite.go#L1-L231)

## 集成测试策略

### 集成测试目标

集成测试验证多个组件协同工作的能力，包括：

- **数据库操作**: 验证数据持久化和查询
- **缓存交互**: 测试Redis缓存功能
- **外部服务**: 验证与第三方服务的集成
- **事务处理**: 确保数据库事务的正确性

### 测试环境配置

集成测试使用Docker容器提供真实的外部依赖：

```yaml
# docker-compose.test.yml
services:
  test-db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: test_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5433:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d test_db"]
      interval: 10s
      timeout: 5s
      retries: 5
```

### 数据库集成测试示例

```go
type AuthIntegrationTestSuite struct {
    suite.Suite
    data     *data.Data
    cleanup  func()
    userRepo biz.UserRepo
    ctx      context.Context
    logger   log.Logger
}

func (suite *AuthIntegrationTestSuite) TestCreateUser() {
    // 准备测试数据
    user := &biz.User{
        Username:  "testuser_" + suite.generateRandomString(8),
        Password:  "$2a$10$hashedpassword",
        Email:     "test@example.com",
        Phone:     "13800138000",
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }

    // 执行测试
    err := suite.userRepo.CreateUser(suite.ctx, user)

    // 验证结果
    assert.NoError(suite.T(), err)
    assert.NotZero(suite.T(), user.ID)

    // 验证用户是否真的被创建
    retrievedUser, err := suite.userRepo.GetUser(suite.ctx, user.Username)
    assert.NoError(suite.T(), err)
    assert.Equal(suite.T(), user.Username, retrievedUser.Username)
}
```

### 并发测试

集成测试包含并发操作验证：

```go
func (suite *AuthIntegrationTestSuite) TestConcurrentOperations() {
    const numGoroutines = 10
    const numOperations = 5

    done := make(chan bool, numGoroutines)
    for i := 0; i < numGoroutines; i++ {
        go func(id int) {
            defer func() { done <- true }()
            
            uniqueUsername := fmt.Sprintf("%s_%d", baseUsername, id)
            
            for j := 0; j < numOperations; j++ {
                lock := &biz.AccountLock{
                    Username:       uniqueUsername,
                    FailedAttempts: int32(j + 1),
                    LockUntil:      time.Now().Add(time.Duration(j+1) * time.Minute),
                    LastAttempt:    time.Now(),
                }
                
                err := suite.userRepo.SaveLock(suite.ctx, lock)
                assert.NoError(suite.T(), err)
                
                _, err = suite.userRepo.GetLock(suite.ctx, uniqueUsername)
                assert.NoError(suite.T(), err)
            }
        }(i)
    }
}
```

**章节来源**
- [test/integration/database/auth_integration_test.go](file://test/integration/database/auth_integration_test.go#L1-L477)
- [test/config/docker-compose.test.yml](file://test/config/docker-compose.test.yml#L1-L112)

## 端到端测试策略

### E2E测试架构

端到端测试模拟完整的用户场景，从前端界面到后端数据库的完整流程：

```mermaid
flowchart TD
Start([开始测试]) --> GetCaptcha["获取验证码"]
GetCaptcha --> Register["注册用户"]
Register --> Login["登录验证"]
Login --> RefreshToken["刷新令牌"]
RefreshToken --> Logout["退出登录"]
Logout --> Cleanup["清理测试数据"]
Cleanup --> End([测试结束])
GetCaptcha --> ValidateCaptcha["验证验证码"]
Register --> ValidateRegistration["验证注册结果"]
Login --> ValidateToken["验证访问令牌"]
RefreshToken --> ValidateNewToken["验证新令牌"]
Logout --> ValidateInvalidation["验证令牌失效"]
```

**图表来源**
- [test/e2e/scenarios/auth_e2e_test.go](file://test/e2e/scenarios/auth_e2e_test.go#L1-L387)

### HTTP客户端测试助手

项目提供了专门的HTTP客户端用于E2E测试：

```go
type APIClient struct {
    baseURL string
    client  *http.Client
}

func (c *APIClient) Register(ctx context.Context, req *v1.RegisterRequest) (*v1.RegisterReply, error) {
    url := fmt.Sprintf("%s/v1/register", c.baseURL)
    body, err := json.Marshal(req)
    if err != nil {
        return nil, err
    }
    
    resp, err := c.client.Post(url, "application/json", bytes.NewBuffer(body))
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var result v1.RegisterReply
    err = json.NewDecoder(resp.Body).Decode(&result)
    return &result, err
}
```

### 完整用户流程测试

```go
Describe("用户注册流程", func() {
    Context("完整的注册流程", func() {
        It("应该能够成功注册新用户", func() {
            By("获取图片验证码")
            captchaResp, err := client.GetCaptcha(ctx, &v1.GetCaptchaRequest{
                CaptchaType: "image",
                Target:      "",
            })
            Expect(err).NotTo(HaveOccurred())
            Expect(captchaResp.CaptchaId).NotTo(BeEmpty())

            By("使用验证码注册用户")
            registerResp, err := client.Register(ctx, &v1.RegisterRequest{
                Username:    testUser.Username,
                Password:    testUser.Password,
                Email:       testUser.Email,
                Phone:       testUser.Phone,
                CaptchaId:   captchaResp.CaptchaId,
                CaptchaCode: "123456",
            })
            Expect(err).NotTo(HaveOccurred())
            Expect(registerResp).NotTo(BeNil())

            By("验证用户已成功创建")
            loginResp, err := client.Login(ctx, &v1.LoginRequest{
                Username:    testUser.Username,
                Password:    testUser.Password,
                CaptchaId:   captchaResp2.CaptchaId,
                CaptchaCode: "123456",
            })
            Expect(err).NotTo(HaveOccurred())
            Expect(loginResp.AccessToken).NotTo(BeEmpty())
        })
    })
})
```

### 测试数据管理

E2E测试包含完善的测试数据清理机制：

```go
BeforeEach(func() {
    // 为每个测试创建唯一的测试用户
    testUser = helpers.NewTestUser()
})

AfterEach(func() {
    // 清理测试数据
    if testUser != nil {
        client.CleanupUser(ctx, testUser.Username)
    }
})
```

**章节来源**
- [test/e2e/scenarios/auth_e2e_test.go](file://test/e2e/scenarios/auth_e2e_test.go#L1-L387)

## 测试基础设施

### 测试环境管理

项目提供了完整的测试环境管理脚本：

```bash
#!/bin/bash
# test/scripts/run_all.sh

# 检测CI环境
detect_ci_environment() {
    if [ "$GITHUB_ACTIONS" = "true" ]; then
        CI_TYPE="github_actions"
        USE_EXTERNAL_SERVICES=true
        SKIP_DOCKER_SETUP=true
    elif [ "$CI" = "true" ]; then
        CI_TYPE="generic_ci"
        USE_EXTERNAL_SERVICES=false
        SKIP_DOCKER_SETUP=false
    else
        CI_TYPE="local"
        USE_EXTERNAL_SERVICES=false
        SKIP_DOCKER_SETUP=false
    fi
}
```

### Mock仓库实现

项目提供了完整的Mock仓库实现用于测试：

```go
type MockKMSRepo struct {
    mu       sync.RWMutex
    dataKeys map[string]*biz.DataKey
    activeID string
}

func (m *MockKMSRepo) SaveDataKey(ctx context.Context, dataKey *biz.DataKey) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    copiedKey := *dataKey
    m.dataKeys[dataKey.ID] = &copiedKey
    
    if dataKey.IsActive {
        for _, key := range m.dataKeys {
            key.IsActive = false
        }
        m.activeID = dataKey.ID
        m.dataKeys[dataKey.ID].IsActive = true
    }
    
    return nil
}
```

### 测试配置管理

项目使用YAML配置文件管理测试环境：

```yaml
# test/config/test.yaml
server:
  http:
    addr: 0.0.0.0:8000
    timeout: 1s
  grpc:
    addr: 0.0.0.0:9000
    timeout: 1s

data:
  database:
    driver: postgres
    source: postgresql://postgres:postgres@localhost:5432/test_db?sslmode=disable
  redis:
    addr: localhost:6379
    read_timeout: 0.2s
    write_timeout: 0.2s

auth:
  jwt_secret_key: "test-secret-key-for-testing-only"
  access_token_expiration: "15m"
  refresh_token_expiration: "168h"
```

**章节来源**
- [test/scripts/run_all.sh](file://test/scripts/run_all.sh#L1-L199)
- [internal/pkg/kms/mock_repository.go](file://internal/pkg/kms/mock_repository.go#L1-L304)
- [test/config/test.yaml](file://test/config/test.yaml#L1-L41)

## 测试覆盖率与质量保障

### 测试覆盖率目标

项目建立了明确的测试覆盖率目标：

- **单元测试**: 70% 覆盖核心逻辑
- **集成测试**: 20% 覆盖系统交互
- **BDD测试**: 30% 覆盖业务流程
- **端到端测试**: 10% 覆盖关键用户场景

### 质量保障实践

1. **测试隔离**: 每个测试用例独立执行，不依赖其他测试状态
2. **数据清理**: 使用适当的清理机制确保测试后环境干净
3. **Mock使用**: 在单元测试中使用Mock隔离外部依赖
4. **真实环境**: 在集成测试中使用真实的外部依赖
5. **场景覆盖**: 端到端测试应覆盖关键的用户场景

### 测试金字塔原则

```mermaid
graph TB
subgraph "测试金字塔"
E2E["端到端测试<br/>10% 覆盖率<br/>高维护成本<br/>慢执行速度"]
Integration["集成测试<br/>20% 覆盖率<br/>中等维护成本<br/>中等执行速度"]
BDD["BDD测试<br/>30% 覆盖率<br/>中等维护成本<br/>较快执行速度"]
Unit["单元测试<br/>40% 覆盖率<br/>低维护成本<br/>极快执行速度"]
end
subgraph "测试价值"
BusinessValue["业务价值验证"]
SystemValue["系统集成验证"]
FeatureValue["功能验证"]
LogicValue["逻辑验证"]
end
E2E --> BusinessValue
Integration --> SystemValue
BDD --> FeatureValue
Unit --> LogicValue
```

**章节来源**
- [test/README.md](file://test/README.md#L1-L152)

## CI/CD集成

### 自动化测试执行

项目提供了完整的CI/CD集成方案：

```bash
# 运行所有测试
./test/scripts/run_all.sh

# 运行特定类型的测试
# 单元测试
go test ./internal/...

# BDD测试
ginkgo -r ./test/bdd/

# 集成测试
go test -tags=integration ./test/integration/...

# 端到端测试
ginkgo -r ./test/e2e/
```

### CI环境适配

测试脚本能够自动识别不同的CI环境：

```bash
# GitHub Actions环境
if [ "$GITHUB_ACTIONS" = "true" ]; then
    CI_TYPE="github_actions"
    USE_EXTERNAL_SERVICES=true
    SKIP_DOCKER_SETUP=true
fi

# 通用CI环境
elif [ "$CI" = "true" ]; then
    CI_TYPE="generic_ci"
    USE_EXTERNAL_SERVICES=false
    SKIP_DOCKER_SETUP=false
fi
```

### 测试报告生成

测试脚本支持生成覆盖率报告：

```bash
# 生成覆盖率报告
go test -coverprofile=coverage.out ./internal/...
go tool cover -html=coverage.out -o coverage.html
```

**章节来源**
- [test/scripts/run_all.sh](file://test/scripts/run_all.sh#L1-L199)
- [test/README.md](file://test/README.md#L40-L80)

## 最佳实践指南

### 测试类型选择决策矩阵

| 测试目标 | 单元测试 | BDD测试 | 集成测试 | E2E测试 |
|---------|---------|---------|----------|----------|
| **测试范围** | 单个函数 | 业务流程 | 系统交互 | 完整旅程 |
| **执行速度** | 极快 | 快 | 中等 | 慢 |
| **维护成本** | 低 | 中 | 中 | 高 |
| **外部依赖** | 无 | Mock | 真实 | 真实 |
| **反馈价值** | 开发时 | 功能验证 | 集成验证 | 用户体验 |

### 测试编写指导原则

1. **快速反馈**: 优先选择执行速度快的测试类型
2. **成本效益**: 考虑维护成本和测试价值的平衡
3. **分层互补**: 不同层次的测试相互补充，而非重复
4. **场景覆盖**: 确保关键业务场景得到充分测试
5. **持续改进**: 定期审查和优化测试策略

### 测试维护建议

1. **定期重构**: 随着业务发展调整测试策略
2. **性能监控**: 监控测试执行时间和覆盖率变化
3. **团队培训**: 确保团队成员掌握测试框架使用
4. **文档更新**: 及时更新测试文档和最佳实践

### 决策问题清单

在编写测试时，问自己以下问题：

- **这个功能影响用户体验吗？** → E2E测试
- **这个功能需要外部服务吗？** → 集成测试  
- **这个功能有复杂业务规则吗？** → BDD测试
- **这个功能是纯逻辑计算吗？** → 单元测试

通过遵循这些最佳实践和指导原则，项目能够建立一个高效、可靠且易于维护的测试体系，确保代码质量和系统稳定性。